///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : calc.cpp
/// SOFTWARE COMPONENT NAME           : Calc
/// GENERATED DATE                    : 2024-08-14 09:44:02
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// INCLUSION HEADER FILES
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <random>

#include "calc/aa/calc.h"
 
namespace calc
{
namespace aa
{
 
Calc::Calc()
    : m_logger(ara::log::CreateLogger("CALC", "SWC", ara::log::LogLevel::kVerbose))
    , m_workers(4) // m_workers.Async에 등록가능한 함수 갯수
    , m_running(false)
    , m_sensorData(0ULL)
{
}
 
Calc::~Calc()
{
}

// Calc Software Component의 초기화 함수.
// 설계하였던 Port 객체들을 생성한다.
bool Calc::Initialize()
{
    m_logger.LogInfo() << "Calc::Initialize";
    
    bool init{true};

    // ControlData PPort 객체의 생성
    m_ControlData = std::make_shared<calc::aa::port::ControlData>();
    // RawData RPort 객체의 생성
    m_RawData = std::make_shared<calc::aa::port::RawData>();
    
    return init;
}

// Calc Software Component의 시작 함수
void Calc::Start()
{
    m_logger.LogInfo() << "Calc::Start";

    // 각 Port들에 대한 Start() 함수를 호출한다.
    m_ControlData->Start();
    m_RawData->Start();
    
    // run software component
    Run();
}

// Calc가 종료되어야 할때 호출되는 함수.
void Calc::Terminate()
{
    m_logger.LogInfo() << "Calc::Terminate";

    m_running = false;

    // 각 Port들에 대한 Terminate() 함수를 호출한다.
    m_ControlData->Terminate();
    m_RawData->Terminate();
}

// Calc Software Component의 수행 함수
void Calc::Run()
{
    m_logger.LogInfo() << "Calc::Run";

    m_running = true;

    // 수행해야 할 작업에 대해 m_workers.Async() 호출을 통해 등록한다.
    m_workers.Async([this] { m_ControlData->SendEventCEventCyclic(); });
    m_workers.Async([this] { TaskReceiveREventCyclic(); });
    m_workers.Async([this] { TaskReceiveNotifyRFieldCyclic(); });
    m_workers.Async([this] { TaskRequestRMethodAndRField(); });

    // 위의 Async로 등록된 함수들이 모두 리턴될때까지 기다린다.
    m_workers.Wait();
}

// RawData REvent의 Cyclic 수신처리에 대한 수행
void Calc::TaskReceiveREventCyclic()
{
    m_RawData->SetReceiveEventREventHandler([this](const auto& sample)
    {
        OnReceiveREvent(sample);
    });
    m_RawData->ReceiveEventREventCyclic();
}

// RawData RField의 Notify Cyclic 수신처리에 대한 수행
void Calc::TaskReceiveNotifyRFieldCyclic()
{
    m_RawData->SetReceiveNotifyRFieldHandler([this](const auto& field)
    {
        OnReceiveNotifyRField(field);
    });
    m_RawData->ReceiveFieldRFieldCyclic();
}

// RawData RMethod에 대한 Method 요청 및
// RawData RField에 대한 RField의 SetField 및 GetField를 Cyclic 요청 수행
void Calc::TaskRequestRMethodAndRField()
{
    // 랜덤 디바이스의 설정.
    // Sensor쪽으로 Set RField 요청시 0 ~ 127 범위의 랜덤한 값을 주기 위한 용도
    std::random_device randomDevice;
    std::default_random_engine randomEngine {randomDevice() };
    std::uniform_int_distribution<std::uint32_t> uint32Gen {0, 127};

    // RField에 대한 SetField Response 처리 핸들러 등록
    m_RawData->SetReceiveSetFieldRFieldHandler([this](const auto& field)
    {
        OnReceiveSetRField(field);
    });
    // RField에 대한 GetField Response 처리 핸들러 등록
    m_RawData->SetReceiveGetFieldRFieldHandler([this](const auto& field)
    {
        OnReceiveGetRField(field);
    });
    // RMethod에 대한 Method Response 처리 핸들러 등록
    m_RawData->SetReceiveMethodRMethodHandler([this](const auto& output)
    {
        OnReceiveRMethod(output);
    });

    while (m_running)
    {
        // Sensor측으로 Method 요청 (kAdd, 더하기)
        m_logger.LogInfo() << "Calc::RequestRMethod (1.0, kAdd, 2.0)";
        m_RawData->RequestRMethod(1.0, deepracer::type::Arithmetic::kAdd, 2.0);
        std::this_thread::sleep_for(std::chrono::seconds(1));
        // Sensor측으로 Method 요청 (kSub, 빼기)
        m_logger.LogInfo() << "Calc::RequestRMethod (5.0, kSub, 3.0)";
        m_RawData->RequestRMethod(5.0, deepracer::type::Arithmetic::kSub, 3.0);
        std::this_thread::sleep_for(std::chrono::seconds(1));
        // Sensor측으로 Method 요청 (kMul)
        m_logger.LogInfo() << "Calc::RequestRMethod (3.0, kMul, 7.0)";
        m_RawData->RequestRMethod(3.0, deepracer::type::Arithmetic::kMul, 7.0);
        std::this_thread::sleep_for(std::chrono::seconds(1));
        // Sensor측으로 Method 요청 (kDiv)
        m_logger.LogInfo() << "Calc::RequestRMethod (8.0, kDiv, 2.0)";
        m_RawData->RequestRMethod(8.0, deepracer::type::Arithmetic::kDiv, 2.0);
        std::this_thread::sleep_for(std::chrono::seconds(1));

        // RField의 필드타입 (uint32_t)의 랜덤값 [0-127] Generate
        deepracer::service::rawdata::proxy::fields::RField::FieldType settingFieldValue = uint32Gen(randomEngine);
        m_logger.LogInfo() << "Calc::RequestSetRField::" << settingFieldValue;
        // Sensor측으로 Set Field 요청
        m_RawData->SetRField(settingFieldValue);
        std::this_thread::sleep_for(std::chrono::seconds(1));
        // Sensor측으로 Get Field 요청
        m_logger.LogInfo() << "Calc::RequestGetRField";
        m_RawData->GetRField();
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}

// RawData REvent를 받았을시의 처리 함수
// 이 부분에서 또다른 랜덤값을 Generate하여 더한 값을 ControlData 서비스의 CEvent의 값으로 설정하여준다.
void Calc::OnReceiveREvent(const deepracer::service::rawdata::proxy::events::REvent::SampleType& sample)
{
    // 랜덤 디바이스의 설정.
    // Actuator 혹은 SimActuator쪽으로 CEvent 전송시 값을 계산하기 위한 Value
    std::random_device randomDevice;
    std::default_random_engine randomEngine {randomDevice() };
    std::uniform_int_distribution<std::uint32_t> uint32Gen {0, 10};

    uint32_t randomValue = uint32Gen(randomEngine);
    m_sensorData = sample + randomValue;
    // ControlData 서비스의 CEvent로 전송해야 할 값을 변경한다. 이 함수는 전송 타겟 값을 변경할 뿐 실제 전송은 다른 부분에서 진행된다.
    m_ControlData->WriteDataCEvent(m_sensorData);
    m_logger.LogInfo() << "Calc::OnReceiveREvent:" << sample << " RandomValue:" << randomValue;
}

// RawData RField Notify를 받았을시의 처리 함수
void Calc::OnReceiveNotifyRField(const deepracer::service::rawdata::proxy::fields::RField::FieldType& field)
{
    m_logger.LogInfo() << "Calc::OnReceiveNotifyRField:" << field;
}

// RawData RField Set에 대한 Response를 받았을시의 처리 함수
void Calc::OnReceiveSetRField(const deepracer::service::rawdata::proxy::fields::RField::FieldType& field)
{
    m_logger.LogInfo() << "Calc::OnReceiveSetRField:" << field;
}

// RawData RField Get에 대한 Response를 받았을시의 처리 함수
void Calc::OnReceiveGetRField(const deepracer::service::rawdata::proxy::fields::RField::FieldType& field)
{
    m_logger.LogInfo() << "Calc::OnReceiveGetRField:" << field;
}

// RawData RMethod에 대한 Response를 받았을시의 처리 함수
void Calc::OnReceiveRMethod(const deepracer::service::rawdata::proxy::methods::RMethod::Output& output)
{
    m_logger.LogInfo() << "Calc::OnReceiveRMethod:" << output.result;
}
 
} /// namespace aa
} /// namespace calc
